<!DOCTYPE html>
<html lang="en" class="no-js">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Proyecto Integrador</title>
		<meta name="description" content="An experimental page transition concept for magazines and blogs where an item opens for a full page view.">
		<meta name="keywords" content="page transition, preview, layout, animation, gsap, magazine, magnetic hover">
		<meta name="author" content="Irving/IvÃ¡n/Luis/Green">
		<link rel="shortcut icon" href="/proyicon.2d29117f.ico">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
		<link rel="stylesheet" href="https://use.typekit.net/ytb6dpl.css">
		<link rel="stylesheet" type="text/css" href="/index.c524e9bf.css">
		<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
		<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"7fFGc":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d751713988987e9331980363e24189ce";
module.bundle.HMR_BUNDLE_ID = "9e603513f66083c0165d482889d785c6";
// @flow
/*global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE*/
/*::
import type {
HMRAsset,
HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
(string): mixed;
cache: {|[string]: ParcelModule|};
hotData: mixed;
Module: any;
parent: ?ParcelRequire;
isParcelRequire: true;
modules: {|[string]: [Function, {|[string]: string|}]|};
HMR_BUNDLE_ID: string;
root: ParcelRequire;
}
interface ParcelModule {
hot: {|
data: mixed,
accept(cb: (Function) => void): void,
dispose(cb: (mixed) => void): void,
// accept(deps: Array<string> | string, cb: (Function) => void): void,
// decline(): void,
_acceptCallbacks: Array<(Function) => void>,
_disposeCallbacks: Array<(mixed) => void>,
|};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || (function () {}));
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, /*: {|[string]: boolean|}*/
acceptedAssets, /*: {|[string]: boolean|}*/
/*: {|[string]: boolean|}*/
assetsToAccept;
function getHostname() {
  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
  return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = getHostname();
  var port = getPort();
  var protocol = HMR_SECURE || location.protocol == 'https:' && !(/localhost|127.0.0.1|0.0.0.0/).test(hostname) ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
  // $FlowFixMe
  ws.onmessage = function (event) /*: {data: string, ...}*/
  {
    checkedAssets = {
      /*: {|[string]: boolean|}*/
    };
    acceptedAssets = {
      /*: {|[string]: boolean|}*/
    };
    assetsToAccept = [];
    var data = /*: HMRMessage*/
    JSON.parse(event.data);
    if (data.type === 'update') {
      // Remove error overlay if there is one
      removeErrorOverlay();
      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);
      // Handle HMR Update
      var handled = false;
      assets.forEach(asset => {
        var didAccept = asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        if (didAccept) {
          handled = true;
        }
      });
      if (handled) {
        console.clear();
        assets.forEach(function (asset) {
          hmrApply(module.bundle.root, asset);
        });
        for (var i = 0; i < assetsToAccept.length; i++) {
          var id = assetsToAccept[i][1];
          if (!acceptedAssets[id]) {
            hmrAcceptRun(assetsToAccept[i][0], id);
          }
        }
      } else {
        window.location.reload();
      }
    }
    if (data.type === 'error') {
      // Log parcel errors to console
      for (let ansiDiagnostic of data.diagnostics.ansi) {
        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
        console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
      }
      // Render the fancy html overlay
      removeErrorOverlay();
      var overlay = createErrorOverlay(data.diagnostics.html);
      // $FlowFixMe
      document.body.appendChild(overlay);
    }
  };
  ws.onerror = function (e) {
    console.error(e.message);
  };
  ws.onclose = function (e) {
    if (undefined !== 'test') {
      console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
    console.log('[parcel] âœ¨ Error resolved');
  }
}
function createErrorOverlay(diagnostics) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;
  let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
  for (let diagnostic of diagnostics) {
    let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
    errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          ðŸš¨ ${diagnostic.message}
        </div>
        <pre>
          ${stack}
        </pre>
        <div>
          ${diagnostic.hints.map(hint => '<div>' + hint + '</div>').join('')}
        </div>
      </div>
    `;
  }
  errorHTML += '</div>';
  overlay.innerHTML = errorHTML;
  return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]>*/
{
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push([bundle, k]);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function updateLink(link) {
  var newLink = link.cloneNode();
  newLink.onload = function () {
    if (link.parentNode !== null) {
      // $FlowFixMe
      link.parentNode.removeChild(link);
    }
  };
  newLink.setAttribute('href', // $FlowFixMe
  link.getAttribute('href').split('?')[0] + '?' + Date.now());
  // $FlowFixMe
  link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
  if (cssTimeout) {
    return;
  }
  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      // $FlowFixMe[incompatible-type]
      var href = /*: string*/
      links[i].getAttribute('href');
      var hostname = getHostname();
      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
      var absolute = (/^https?:\/\//i).test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
      if (!absolute) {
        updateLink(links[i]);
      }
    }
    cssTimeout = null;
  }, 50);
}
function hmrApply(bundle, /*: ParcelRequire*/
asset) /*:  HMRAsset*/
{
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (asset.type === 'css') {
    reloadCSS();
    return;
  }
  let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
  if (deps) {
    var fn = new Function('require', 'module', 'exports', asset.output);
    modules[asset.id] = [fn, deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, /*: ParcelRequire*/
id, /*: ParcelRequire*/
/*: string*/
depsByBundle) /*: ?{ [string]: { [string]: string } }*/
{
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
    // If we reached the root bundle without finding where the asset should go,
    // there's nothing to do. Mark as "accepted" so we don't reload the page.
    if (!bundle.parent) {
      return true;
    }
    return hmrAcceptCheck(bundle.parent, id, depsByBundle);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(module.bundle.root, id).some(function (v) {
    return hmrAcceptCheck(v[0], v[1], null);
  });
}
function hmrAcceptRun(bundle, /*: ParcelRequire*/
id) /*: string*/
{
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached && cached.hot) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      var assetsToAlsoAccept = cb(function () {
        return getParents(module.bundle.root, id);
      });
      if (assetsToAlsoAccept && assetsToAccept.length) {
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
      }
    });
  }
  acceptedAssets[id] = true;
}

},{}],"1AtJe":[function(require,module,exports) {
document.documentElement.className="js";var supportsCssVars=function(){var e,t=document.createElement("style");return t.innerHTML="root: { --tmp-var: bold; }",document.head.appendChild(t),e=!!(window.CSS&&window.CSS.supports&&window.CSS.supports("font-weight","var(--tmp-var)")),t.parentNode.removeChild(t),e};supportsCssVars()||alert("Please view this demo in a modern browser that supports CSS Variables.");
},{}]},["7fFGc","1AtJe"], "1AtJe", "parcelRequire938f")

</script>
	</head>
	<body class="loading">
		<main>
			<div class="frame">
				<div class="frame__title-wrap">
					<h1 class="frame__title">Redes y seguridad - Proyecto Integrador</h1>
					<p class="frame__tagline">Ã‰sta pagina tiene como objetivo proveer informacion educacional sobre temas de redes y seguridad de computadoras.</p>
				</div>
				<nav class="frame__links">
					<a target="_blank">Luis Juarez</a>
					<a target="_blank">Iv&aacute;n Cetina</a>
					<a target="_blank">Carlos Greene</a>
					<a target="_blank">Irving Poot</a>
				</nav>
			</div>
			<section class="items">
				<article class="item">
					<div class="item__imgwrap">
						<div class="item__img" style="background-image:url(honeynets.2e25a0da.jpg)
"></div>
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">Honey</span>
						<span data-splitting="">nets</span>
					</h2>
					<div class="item__meta">
						<span class="item__meta-row"><span>Honey nets</span></span>
					</div>
					<div class="item__excerpt">
						<p>
							Las honeynets son herramientas poderosas que proporcionan una comprensiÃ³n profunda de las amenazas cibernÃ©ticas actuales, 
							permitiendo a los profesionales de la seguridad fortalecer sus defensas 
							y capacidades de detecciÃ³n mediante el anÃ¡lisis detallado de los datos recopilados.
						</p>
						<a class="item__excerpt-link" href="#content-1"><span>Leer m&aacute;s</span></a>
					</div>
				</article>
				<article class="item item--invert">
					<div class="item__imgwrap">
						<div class="item__img" style="background-image:url(tunneling.f553142d.png)
"></div>
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">TunelizaciÃ³n</span>
						<span data-splitting="">(tunneling)</span>
					</h2>
					<div class="item__meta">
						<span class="item__meta-row"><span>Tunneling</span></span>
					</div>
					<div class="item__excerpt">
						<p>
							La tunelizaciÃ³n de protocolos es una tÃ©cnica que permite que dos redes con diferentes protocolos se comuniquen. Un protocolo de tunelizaciÃ³n encapsula en su datagrama otro paquete de datos completo que utiliza un protocolo de comunicaciones diferente.
						</p>
						<a class="item__excerpt-link" href="#content-2"><span>Leer m&aacute;s</span></a>
					</div>
				</article>
				<article class="item">
					<div class="item__imgwrap">
						<div class="item__img" style="background-image:url(iot.10a9dc38.png)
"></div>
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">Internet</span>
						<span data-splitting="">of</span>
						<span data-splitting="">things</span>
					</h2>
					<div class="item__meta">
						<span class="item__meta-row"><span>Internet of things</span></span>
					</div>
					<div class="item__excerpt">
						<p>
							El Internet de las Cosas (IoT, por sus siglas en inglÃ©s) se refiere a la conexiÃ³n de objetos fÃ­sicos a travÃ©s de internet, permitiÃ©ndoles recopilar y compartir datos. Estos objetos, o "cosas", pueden incluir dispositivos domÃ©sticos, vehÃ­culos, electrodomÃ©sticos, sensores, y mÃ¡s. 
							La idea principal es que estos dispositivos puedan comunicarse entre sÃ­ y con sistemas en la nube para recopilar, analizar y utilizar datos de manera eficiente.
						</p>
						<a class="item__excerpt-link" href="#content-3"><span>Leer m&aacute;s</span></a>
					</div>
				</article>
				<article class="item">
					<div class="item__imgwrap">
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">Cr&eacute;ditos</span>
					</h2>
					<div class="item__excerpt">
						<p>Fuentes utilizadas para la creaciÃ³n de esta pÃ¡gina.</p>
						<a class="item__excerpt-link" href="#content-4"><span>Read more</span></a>
					</div>
				</article>
				
			<!-- AquÃ­ comienza el texto de los articulos -->
			<section class="content">
				<article class="content__article" id="content-1">
					<h2 class="heading">
						<span data-splitting="">Honey</span>
						<span data-splitting="">nets</span>
					</h2>
					<div class="content__text">
						<p>
							Una honeynet son herramientas de seguridad que simula una red completa para ser atacada por intrusos. 
							Funciona como una especie de "pecera" donde se observa al atacante en su entorno. Esta red consta de sistemas dispuestos a recibir ataques, con mecanismos para monitorear y registrar las acciones del intruso. Estudiar el comportamiento del atacante permite entender sus tÃ¡cticas y motivaciones. 
							Las honeynets son los honeypots mÃ¡s avanzados y esta presentaciÃ³n destaca su poder, examina diferentes propuestas y resalta la importancia de su virtualizaciÃ³n. 
						</p>
						<img src="/honeynetstxt1.8c728074.jpg" alt="Some image">
						<p>
							Una honeypot es una herramienta que se utiliza como seÃ±uelo, con el fin de ser atacada, por esto todo trÃ¡fico que pase por ella serÃ¡ detectado como un ataque o intrusiÃ³n. 
							Una honeypot no tendrÃ¡ comunicaciÃ³n alguna con ninguna entidad y, en caso de detectar trÃ¡fico cuyo origen sea el honeypot, este serÃ¡ tomado inmediatamente como una amenaza.
						</p>
						<p>
							Por lo tanto, una honeynet representa la forma mÃ¡s sofisticada de honeypot, ofreciendo un alto nivel de interacciÃ³n con los intrusos y permitiendo una recopilaciÃ³n extensa de datos sobre ataques. 
							Sin ser una herramienta lista para ser instalada, es una red completa con sistemas diseÃ±ados para ser atacados, pudiendo simular cualquier componente de red, incluyendo routers y switches, imitando asÃ­ una red real de una organizaciÃ³n.
						</p>
						<p>
							El desarrollo de estas redes ha sido impulsado por el Honeynet Project, fundado en el aÃ±o 2000, cuyo propÃ³sito es comprender las tÃ©cnicas y motivaciones de los atacantes y compartir conocimientos al respecto. 
							Este proyecto reÃºne a expertos en sistemas operativos, desarrolladores de herramientas de seguridad, psicÃ³logos y otros perfiles diversos. 
						</p>
						<img src="/honeynetstxt2.1dd26eb8.png" alt="Some image">
						<p>
							AdemÃ¡s de los sistemas destinados a recibir ataques, una honeynet incluye dispositivos adicionales para detectar, filtrar y registrar el trÃ¡fico entrante y saliente, asÃ­ como las acciones de los intrusos una vez que comprometen un sistema simulado. 
							Todo esto se realiza de manera pasiva para no alertar al intruso sobre su monitoreo. Estos dispositivos cumplen funciones clave:
							</p><ul>
								<li>
									<strong>Control del intruso:</strong> Filtrar las conexiones nocivas del intruso y evitar que utilice sistemas comprometidos para atacar otros recursos.
								</li>
								<li>
									<strong>Captura de datos:</strong> Registrar todo el trÃ¡fico dentro y fuera de la honeynet, asÃ­ como las acciones del intruso en sistemas comprometidos para estudiar tÃ¡cticas y motivaciones de los atacantes.
								</li>
								<li>
									<strong>CentralizaciÃ³n de informaciÃ³n:</strong> Enviar de manera segura los datos capturados a un servidor centralizado para su almacenamiento y anÃ¡lisis, permitiendo un mejor control y anÃ¡lisis de las experiencias recopiladas y una visiÃ³n mÃ¡s clara de los diferentes tipos de ataques en la red.
								</li>
							</ul>
						<p></p>
						<p>
							La eficacia de una honeynet radica en su capacidad para recopilar datos detallados, esenciales para entender y combatir las amenazas cibernÃ©ticas, 
							permitiendo un anÃ¡lisis exhaustivo de las tÃ¡cticas utilizadas por los atacantes y facilitando estrategias de defensa mÃ¡s robustas.
						</p>
						<p>
							Volviendo con el proyecto honeynet, muestran las herramientas usadas para la recolecciÃ³n de datos en honeynet aunque solo muestran las mÃ¡s usadas por la organizaciÃ³n:
							</p><ul>
								<li><strong>Honeyned:</strong> Emula los almacena IP de varios sistemas operativos y provee de manera opcional servicio de emulaciÃ³n bÃ¡sica.</li>
								<li><strong>Nephentes:</strong> Emula vulnerabilidades comunes de MS Windows; es extremadamente bueno capturando malware como gusanos.</li>
								<li><strong>Honeytrap:</strong> Detecta intentos de conexiÃ³n contra puertos TCP no conectados.</li>
								<li><strong>Kojoney:</strong> Emula los procesos de un servidor SSH y graba los nombres de usuario y contraseÃ±as de los atacantes.</li>
								<li><strong>Sebek:</strong> Monitorea los honepots de alta interacciÃ³n, engancha llamadas de lectura o escritura para manipular el acceso de archivos o actividad de entrada y salida.</li>
								<li><strong>Hflow:</strong> Cruza datos obtenidos en Snort, pof y sebek en una estructura de datos relacionada para almacenamiento en una base de datos terminal.</li>
								<li><strong>Honeywall:</strong> Es usando para construir de forma rÃ¡pida una honeynet de alta interacciÃ³n. Permite un anÃ¡lisis y control transparente de los datos.</li>
								<li><strong>Capture HPC:</strong> Ejecuta aplicaciones dentro de una mÃ¡quina virtual de Windows, aunque su mayor uso ha sido encontrar posibles URL maliciosas.</li>
								<li><strong>SpamPot:</strong> Colecciona y analiza mensajes vÃ­a email.</li>
							</ul>
						<p></p>
						<p>
							Sin embargo, existen algunos inconvenientes en el uso de este tipo de herramientas pues se requiere de una instalaciÃ³n con total precisiÃ³n y cuidado, de tal forma que la seguridad de la red no se vea comprometida en este punto, ademÃ¡s de otros problemas legales que esto acarrearÃ­a.
						</p>
						<p>
							Por lo tanto, las honeynets Son herramientas altamente especializadas diseÃ±adas para simular entornos de red completos y capturar informaciÃ³n detallada sobre tÃ¡cticas de ataque y comportamiento de los intrusos, esta informaciÃ³n es vital para entender las amenazas y mejorar las defensas de seguridad. 
							La evoluciÃ³n de las honeynets se ha producido gracias a proyectos como el Honeynet Project, que reÃºne a expertos de diversos campos para comprender mejor las tÃ¡cticas y motivaciones de los atacantes, mejorando asÃ­ las estrategias de defensa cibernÃ©tica. 
							Aunque pasivamente monitorean las acciones de los intrusos para no alertarlos, activamente controlan y filtran las conexiones maliciosas para evitar daÃ±os mayores.
						</p>
					</div>
				</article>
				<article class="content__article content__article--invert" id="content-2">
					<h2 class="heading">
						<span data-splitting="">Tunelizaci&oacute;n</span>
						<span data-splitting="">(Tunneling)</span>
					</h2>
					<div class="content__text">
						<p>
							La encapsulaciÃ³n de paquetes en la tunelizaciÃ³n se logra mediante el envoltorio de un paquete de datos completo que utiliza un protocolo de comunicaciones diferente dentro del datagrama de un protocolo de tunelizaciÃ³n. 
							El paquete encapsulado se transmite a travÃ©s de la red y se desencapsula en el extremo receptor para recuperar el paquete original.
						</p>
						<img style="width: 60%; height: auto;
" src="/tunnelingtxt1.ff02f2f1.png" alt="some image">
						<p>
							Por ejemplo, el protocolo de enrutamiento genÃ©rico (GRE) es un protocolo de tunelizaciÃ³n que encapsula paquetes de datos que utilizan un protocolo de enrutamiento dentro de los paquetes de otro protocolo. GRE permite el uso de protocolos que no suelen ser compatibles con una red, porque los paquetes estÃ¡n envueltos dentro de otros paquetes que sÃ­ utilizan protocolos compatibles. 
						</p>
						<p>
							La encapsulaciÃ³n es Ãºtil porque permite dividir un flujo de datos en unidades mÃ¡s pequeÃ±as para las transmisiones a travÃ©s de la red, lo que aumenta la velocidad y la eficiencia de la transmisiÃ³n. 
							AdemÃ¡s, la encapsulaciÃ³n ayuda a aumentar la seguridad de los datos y la privacidad del acceso no autorizado
						</p>
						<p>
							No obstante, no estamos exentos de riesgos en la red. Un tÃºnel VPN es una conexiÃ³n encriptada entre tu dispositivo e internet. 
							Los hackers, snoopers, ISPs y gobiernos pueden transformar tu vida digital en un infierno. No es muy difÃ­cil que nos hackeen en internet, sufrir los efectos de la censura o encontrarnos con una barrera para acceder a ciertos servicios. 
							Un tÃºnel VPN te ayudarÃ¡ a protegerte de todos estos problemas. Un tÃºnel VPN es una conexiÃ³n encriptada entre tu dispositivo e internet. 
							Al descargar una VPN para conectarte a internet, tu trÃ¡fico de internet pasa a travÃ©s de un tÃºnel encriptado, asegura tus datos y los redirige a uno de los servidores del proveedor VPN. Puedes sentarte frente a tu equipo en el Reino Unido y pretender que estÃ¡s en CanadÃ¡. 
							Ni los ISPs ni los hackers podrÃ¡n identificarte, espiar tus datos o rastrear tu ubicaciÃ³n.
						</p>
						<img style="width: 60%; height: auto;
" src="/tunnelingtxt2.24455b09.png" alt="some image">
						<p>
							Tipos de protocolos:
							</p><ul>
								<li><strong>PPP (Point-to-Point Protocol): </strong>Es un protocolo del nivel de enlace de datos, utilizado para establecer una conexiÃ³n directa entre dos nodos de una red. Se emplea en varios tipos de redes fÃ­sicas, incluyendo: lÃ­nea telefÃ³nica, telefonÃ­a celular y enlace de fibra Ã³ptica.</li>
								<li><strong>GRE (Generic Routing Encapsulation):</strong> Es un protocolo para el establecimiento de tÃºneles a travÃ©s de Internet, que soporta secuencialidad de paquetes, permite establecer polÃ­ticas de enrutamiento y seguridad, facilita encapsular una amplia variedad de tipos de paquete dentro de tÃºneles IP.</li>
								<li><strong>PPTP (Point-to-Point Tunneling Protocol):</strong> Es un protocolo de comunicaciones actualmente en desuso, que permite el intercambio seguro de datos de un cliente a un servidor formando una Red Privada Virtual (VPN).</li>
								<li><strong>PSec (Internet Protocol Security):</strong> su funciÃ³n es asegurar las comunicaciones IP y a los protocolos de capas superiores, autenticando y/o cifrando cada paquete de datos que se intercambia.</li>
							</ul>
						<p></p>
						<img src="/tunnelingtxt3.99d9e19d.png" alt="some image">
						<p>
							Existen mÃ¡s protocolos referentes a la tunelizaciÃ³n, no obstante solo elegimos estos para fines prÃ¡cticos.
						</p>
					</div>
				</article>
				<article class="content__article" id="content-3">
					<h2 class="heading">
						<span data-splitting="">Internet</span>
						<span data-splitting="">of</span>
						<span data-splitting="">Things</span>
					</h2>
					<div class="content__text">
						<p>
							La IoT se refiere a la interconexiÃ³n en red de todos los objetos cotidianos, que a menudo estÃ¡n equipados con algÃºn tipo de inteligencia. 
							En este contexto, Internet puede ser tambiÃ©n una plataforma para dispositivos que se comunican electrÃ³nicamente y comparten informaciÃ³n y datos especÃ­ficos con el mundo que les rodea. 
							AsÃ­, la IoT puede verse como una verdadera evoluciÃ³n de lo que conocemos como Internet aÃ±adiendo una interconectividad mÃ¡s extensa, una mejor percepciÃ³n de la informaciÃ³n y servicios inteligentes mÃ¡s completos. 
							En su mayor parte, se utilizÃ³ la Internet para protocolos orientados a la conexiÃ³n de aplicaciones como HTTP (Protocolo de transferencia de hipertexto) y SMTP (Simple Mail Transfer Protocol). Sin embargo, hoy en dÃ­a un gran nÃºmero de dispositivos inteligentes se comunican entre ellos y con otros sistemas de control. 
							Este concepto se conoce como M2M (comunicaciones de mÃ¡quina a mÃ¡quina). 
						</p>
						<img src="/iottext1.e444c210.png" alt="Some image">
						<p>
							Hay tres componentes o elementos bÃ¡sicos que interactÃºan entre sÃ­:
							</p><ul>
								<li><strong>Hardware:</strong> sensores, actuadores (dispositivos que controlan los sistemas) y otros dispositivos de comunicaciÃ³n alojados en los objetos;</li>
								<li><strong>Plataforma de middleware:</strong> Que es el software que permite el intercambio de informaciÃ³n entre las aplicaciones, asÃ­ como las herramientas computacionales que permitan el anÃ¡lisis de datos</li>
								<li>Las herramientas que en forma fÃ¡cil permitan la visualizaciÃ³n e interpretaciÃ³n de la informaciÃ³n y que deben ser diseÃ±adas para ser accesadas por diferentes aplicaciones y dispositivos</li>
							</ul>
						<p></p>
						<p>
							Actualmente, IoT estÃ¡ compuesta por una colecciÃ³n dispersa de redes diferentes y con distintos fines. Por ejemplo, los automÃ³viles actuales tienen mÃºltiples redes para controlar el funcionamiento del motor, las medidas de seguridad, los sistemas de comunicaciÃ³n y asÃ­ sucesivamente. 
							De forma similar, los edificios comerciales y residenciales tienen distintos sistemas de control para la calefacciÃ³n, la ventilaciÃ³n y el aire acondicionado, la telefonÃ­a, la seguridad y la iluminaciÃ³n. A medida que IoT evoluciona, estas redes y muchas otras estarÃ¡n conectadas con la incorporaciÃ³n de capacidades de seguridad, anÃ¡lisis y administraciÃ³n.
						</p>
						<img src="/iottext2.b50d6454.png" alt="Some image">
						<p>
							A medida que sigue aumentando la poblaciÃ³n del planeta, se torna cada vez mÃ¡s importante que las personas se conviertan en guardianes de la Tierra y sus recursos. AdemÃ¡s, las personas desean vidas saludables, plenas y confortables para sÃ­ mismas, sus familias y las personas que quieren. Si se combina la capacidad de la prÃ³xima evoluciÃ³n de Internet (IoT) para percibir, recolectar, transmitir, analizar y distribuir datos a escala masiva con la manera en que las personas procesan la informaciÃ³n, la humanidad tendrÃ¡ el conocimiento y la sabidurÃ­a necesarios no solo para sobrevivir sino para mejorar y prosperar en los prÃ³ximos meses, aÃ±os, dÃ©cadas y siglos. 
						</p>
						<p>
							El IoT tiene el potencial de mejorar la eficiencia y la comodidad en diversas Ã¡reas, como la domÃ³tica, la salud, la agricultura, la industria y el transporte. Los dispositivos IoT pueden recopilar informaciÃ³n en tiempo real, automatizar procesos y permitir a los usuarios tomar decisiones informadas basadas en datos.
						</p>
						<p>
							No obstante, son varias las barreras que podrÃ­an retrasar el desarrollo de IoT. Las tres barreras de mayor magnitud son la implementaciÃ³n de IPv6, la energÃ­a para alimentar los sensores y el acuerdo sobre las normas.
							</p><ul>
								<li><strong>ImplementaciÃ³n de IPv6:</strong> En febrero de 2010, se agotaron las direcciones IPv4 del mundo. Si bien el pÃºblico general no ha observado un impacto real, esta situaciÃ³n podrÃ­a lentificar el progreso de IoT, ya que los posibles miles de millones de sensores necesitarÃ¡n direcciones IP exclusivas. AdemÃ¡s, IPv6 facilita la administraciÃ³n de las redes gracias a las capacidades de autoconfiguraciÃ³n y ofrece caracterÃ­sticas de seguridad mejoradas. </li>
								<li><strong>EnergÃ­a para los sensores:</strong> Para que IoT alcance su mÃ¡ximo potencial, los sensores deberÃ¡n ser autosustentables. Imagine cambiar las baterÃ­as de miles de millones de dispositivos implementados en todo el planeta e incluso en el espacio. Obviamente, no es posible. Lo que se necesita es una forma de que los sensores generen electricidad a partir de elementos medioambientales como las vibraciones, la luz y las corrientes de aire.</li>
								<li><strong>Normas:</strong> Si bien se han realizado grandes progresos en cuanto a las normas, se necesita aÃºn mÃ¡s, especialmente en las Ã¡reas de seguridad, privacidad, arquitectura y comunicaciones, ya que la gran cantidad de informaciÃ³n generada y compartida puede ser vulnerable a amenazas cibernÃ©ticas. IEEE es solo una de las organizaciones que actualmente trabajan para sortear estas dificultades, con la tarea de garantizar que los paquetes de IPv6 se puedan direccionar a travÃ©s de tipos de red diferentes.</li>
							</ul>
						<p></p>
					</div>
				</article>
				<article class="content__article" id="content-4">
					<h2 class="heading">
						<span data-splitting="">Creditos</span>
					</h2>
					<div class="content__text">
						<p>
							</p><ul>
								<li>Gallego, E., LÃ³pez, J. (s.f.). <em>Honeynets: Aprendiendo del Atacante.</em> Departamento de IngenierÃ­a de Sistemas TelemÃ¡ticos, Universidad PolitÃ©cnica de Madrid E.T.S.I. de TelecomunicaciÃ³n, Av. Complutense, s/n, 28040 Madrid, EspaÃ±a.</li>
								<li>Gaona, P., Montenegro, C., BarÃ³n, J. (2016). <em>Modelo ontolÃ³gico para la predicciÃ³n de ataques informÃ¡ticos a partir de Honeynets virtualizadas.</em></li>
								<li>BTOBAdmin. (2022, 1 septiembre). Â¿QUÃ‰ SIGNIFICA HACER TÃšNEL? (TUNNELING PROTOCOL) | BTOB Consultores. BTOB Consultores. https://btob.com.mx/ciberseguridad/que-significa-hacer-tunel/</li>
								<li>Â¿QuÃ© es un protocolo de tunelizaciÃ³n? (2023, 19 abril). latam.kaspersky.com. https://latam.kaspersky.com/resource-center/definitions/tunneling-protocol </li>
								<li>Salazar J., Silvestre S., (2020) Internet de las cosas. Tech pedia, recuperado de https://upcommons.upc.edu/bitstream/handle/2117/100921/LM08_R_ES.pdf</li>
								<li>Evans D., (2011). Internet de las cosas CÃ³mo la prÃ³xima evoluciÃ³n de Internet lo cambia todo. Cisco, recuperado de  https://www.cisco.com/c/dam/global/es_mx/solutions/executive/assets/pdf/ <br> internet-of-things-iot-ibsg.pdf</li>
								<li>Bonilla-Fabela, I., Tavizon-Salazar, A., et. al. (2016) IoT, el internet de las cosas y la innovaciÃ³n de sus aplicaciones. ISSN: 2448-5101 AÃ±o 2 NÃºmero 1, recuperado de http://www.web.facpya.uanl.mx/Vinculategica/Revistas/R2/2313-2340%20-%20Iot,%20El%20Internet%20De%20Las%20Cosas%20Y%20La%20Innovacion <br> %20De%20Sus%20Aplicaciones.pdf</li>
							</ul>
						<p></p>
					</div>
				</article>
				<button class="content__back unbutton">
					<svg width="108" height="23" viewbox="0 0 108 23">
						<path stroke="#000" fill="none" d="M107.5 11.5H1.5M1.5 11.5c8.975-.536 15.087-1.364 18.336-2.484C23.086 7.896 26.64 5.39 30.5 1.5M1.5 11.5c8.975.536 15.087 1.364 18.336 2.484 3.25 1.12 6.804 3.626 10.664 7.516"></path>
					</svg>
				</button>
			</section>
		</section></main>
		<footer class="frame__links frame frame--footer footerlink">
			<a target="_blank">&copy;</a>
			<a target="_blank">Luis Juarez</a>
			<a target="_blank">Iv&aacute;n Cetina</a>
			<a target="_blank">Carlos Greene</a>
			<a target="_blank">Irving Poot</a>
		</footer>
		<script src="/index.2142d36c.js"></script>
	</body>
</html>