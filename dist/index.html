<!DOCTYPE html>
<html lang="en" class="no-js">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Proyecto Integrador</title>
		<meta name="description" content="An experimental page transition concept for magazines and blogs where an item opens for a full page view.">
		<meta name="keywords" content="page transition, preview, layout, animation, gsap, magazine, magnetic hover">
		<meta name="author" content="Irving/Iv√°n/Luis/Green">
		<link rel="shortcut icon" href="/proyicon.2d29117f.ico">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
		<link rel="stylesheet" href="https://use.typekit.net/ytb6dpl.css">
		<link rel="stylesheet" type="text/css" href="/index.c524e9bf.css">
		<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
		<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"7fFGc":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d751713988987e9331980363e24189ce";
module.bundle.HMR_BUNDLE_ID = "9e603513f66083c0165d482889d785c6";
// @flow
/*global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE*/
/*::
import type {
HMRAsset,
HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
(string): mixed;
cache: {|[string]: ParcelModule|};
hotData: mixed;
Module: any;
parent: ?ParcelRequire;
isParcelRequire: true;
modules: {|[string]: [Function, {|[string]: string|}]|};
HMR_BUNDLE_ID: string;
root: ParcelRequire;
}
interface ParcelModule {
hot: {|
data: mixed,
accept(cb: (Function) => void): void,
dispose(cb: (mixed) => void): void,
// accept(deps: Array<string> | string, cb: (Function) => void): void,
// decline(): void,
_acceptCallbacks: Array<(Function) => void>,
_disposeCallbacks: Array<(mixed) => void>,
|};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || (function () {}));
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, /*: {|[string]: boolean|}*/
acceptedAssets, /*: {|[string]: boolean|}*/
/*: {|[string]: boolean|}*/
assetsToAccept;
function getHostname() {
  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
  return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = getHostname();
  var port = getPort();
  var protocol = HMR_SECURE || location.protocol == 'https:' && !(/localhost|127.0.0.1|0.0.0.0/).test(hostname) ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
  // $FlowFixMe
  ws.onmessage = function (event) /*: {data: string, ...}*/
  {
    checkedAssets = {
      /*: {|[string]: boolean|}*/
    };
    acceptedAssets = {
      /*: {|[string]: boolean|}*/
    };
    assetsToAccept = [];
    var data = /*: HMRMessage*/
    JSON.parse(event.data);
    if (data.type === 'update') {
      // Remove error overlay if there is one
      removeErrorOverlay();
      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);
      // Handle HMR Update
      var handled = false;
      assets.forEach(asset => {
        var didAccept = asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        if (didAccept) {
          handled = true;
        }
      });
      if (handled) {
        console.clear();
        assets.forEach(function (asset) {
          hmrApply(module.bundle.root, asset);
        });
        for (var i = 0; i < assetsToAccept.length; i++) {
          var id = assetsToAccept[i][1];
          if (!acceptedAssets[id]) {
            hmrAcceptRun(assetsToAccept[i][0], id);
          }
        }
      } else {
        window.location.reload();
      }
    }
    if (data.type === 'error') {
      // Log parcel errors to console
      for (let ansiDiagnostic of data.diagnostics.ansi) {
        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
        console.error('üö® [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
      }
      // Render the fancy html overlay
      removeErrorOverlay();
      var overlay = createErrorOverlay(data.diagnostics.html);
      // $FlowFixMe
      document.body.appendChild(overlay);
    }
  };
  ws.onerror = function (e) {
    console.error(e.message);
  };
  ws.onclose = function (e) {
    if (undefined !== 'test') {
      console.warn('[parcel] üö® Connection to the HMR server was lost');
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
    console.log('[parcel] ‚ú® Error resolved');
  }
}
function createErrorOverlay(diagnostics) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;
  let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
  for (let diagnostic of diagnostics) {
    let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
    errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>
          ${stack}
        </pre>
        <div>
          ${diagnostic.hints.map(hint => '<div>' + hint + '</div>').join('')}
        </div>
      </div>
    `;
  }
  errorHTML += '</div>';
  overlay.innerHTML = errorHTML;
  return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]>*/
{
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push([bundle, k]);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function updateLink(link) {
  var newLink = link.cloneNode();
  newLink.onload = function () {
    if (link.parentNode !== null) {
      // $FlowFixMe
      link.parentNode.removeChild(link);
    }
  };
  newLink.setAttribute('href', // $FlowFixMe
  link.getAttribute('href').split('?')[0] + '?' + Date.now());
  // $FlowFixMe
  link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
  if (cssTimeout) {
    return;
  }
  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      // $FlowFixMe[incompatible-type]
      var href = /*: string*/
      links[i].getAttribute('href');
      var hostname = getHostname();
      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
      var absolute = (/^https?:\/\//i).test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
      if (!absolute) {
        updateLink(links[i]);
      }
    }
    cssTimeout = null;
  }, 50);
}
function hmrApply(bundle, /*: ParcelRequire*/
asset) /*:  HMRAsset*/
{
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (asset.type === 'css') {
    reloadCSS();
    return;
  }
  let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
  if (deps) {
    var fn = new Function('require', 'module', 'exports', asset.output);
    modules[asset.id] = [fn, deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, /*: ParcelRequire*/
id, /*: ParcelRequire*/
/*: string*/
depsByBundle) /*: ?{ [string]: { [string]: string } }*/
{
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
    // If we reached the root bundle without finding where the asset should go,
    // there's nothing to do. Mark as "accepted" so we don't reload the page.
    if (!bundle.parent) {
      return true;
    }
    return hmrAcceptCheck(bundle.parent, id, depsByBundle);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(module.bundle.root, id).some(function (v) {
    return hmrAcceptCheck(v[0], v[1], null);
  });
}
function hmrAcceptRun(bundle, /*: ParcelRequire*/
id) /*: string*/
{
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached && cached.hot) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      var assetsToAlsoAccept = cb(function () {
        return getParents(module.bundle.root, id);
      });
      if (assetsToAlsoAccept && assetsToAccept.length) {
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
      }
    });
  }
  acceptedAssets[id] = true;
}

},{}],"1AtJe":[function(require,module,exports) {
document.documentElement.className="js";var supportsCssVars=function(){var e,t=document.createElement("style");return t.innerHTML="root: { --tmp-var: bold; }",document.head.appendChild(t),e=!!(window.CSS&&window.CSS.supports&&window.CSS.supports("font-weight","var(--tmp-var)")),t.parentNode.removeChild(t),e};supportsCssVars()||alert("Please view this demo in a modern browser that supports CSS Variables.");
},{}]},["7fFGc","1AtJe"], "1AtJe", "parcelRequire938f")

</script>
	</head>
	<body class="loading">
		<main>
			<div class="frame">
				<div class="frame__title-wrap">
					<h1 class="frame__title">Redes y seguridad - Proyecto Integrador</h1>
					<p class="frame__tagline">√âsta pagina tiene como objetivo proveer informacion educacional sobre temas de redes y seguridad de computadoras.</p>
				</div>
				<nav class="frame__links">
					<a target="_blank">Luis Juarez</a>
					<a target="_blank">Iv&aacute;n Cetina</a>
					<a target="_blank">Carlos Greene</a>
					<a target="_blank">Irving Poot</a>
				</nav>
			</div>
			<section class="items">
				<article class="item">
					<div class="item__imgwrap">
						<div class="item__img" style="background-image:url(honeynets.2e25a0da.jpg)
"></div>
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">Honey</span>
						<span data-splitting="">nets</span>
					</h2>
					<div class="item__meta">
						<span class="item__meta-row"><span>Honey nets</span></span>
					</div>
					<div class="item__excerpt">
						<p>
							Las honeynets son herramientas poderosas que proporcionan una comprensi√≥n profunda de las amenazas cibern√©ticas actuales, 
							permitiendo a los profesionales de la seguridad fortalecer sus defensas 
							y capacidades de detecci√≥n mediante el an√°lisis detallado de los datos recopilados.
						</p>
						<a class="item__excerpt-link" href="#content-1"><span>Leer m&aacute;s</span></a>
					</div>
				</article>
				<article class="item item--invert">
					<div class="item__imgwrap">
						<div class="item__img" style="background-image:url(tunneling.f553142d.png)
"></div>
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">Tunelizaci√≥n</span>
						<span data-splitting="">(tunneling)</span>
					</h2>
					<div class="item__meta">
						<span class="item__meta-row"><span>Tunneling</span></span>
					</div>
					<div class="item__excerpt">
						<p>
							La tunelizaci√≥n de protocolos es una t√©cnica que permite que dos redes con diferentes protocolos se comuniquen. Un protocolo de tunelizaci√≥n encapsula en su datagrama otro paquete de datos completo que utiliza un protocolo de comunicaciones diferente.
						</p>
						<a class="item__excerpt-link" href="#content-2"><span>Leer m&aacute;s</span></a>
					</div>
				</article>
				<article class="item">
					<div class="item__imgwrap">
						<div class="item__img" style="background-image:url(iot.10a9dc38.png)
"></div>
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">Internet</span>
						<span data-splitting="">of</span>
						<span data-splitting="">things</span>
					</h2>
					<div class="item__meta">
						<span class="item__meta-row"><span>Internet of things</span></span>
					</div>
					<div class="item__excerpt">
						<p>
							El Internet de las Cosas (IoT, por sus siglas en ingl√©s) se refiere a la conexi√≥n de objetos f√≠sicos a trav√©s de internet, permiti√©ndoles recopilar y compartir datos. Estos objetos, o "cosas", pueden incluir dispositivos dom√©sticos, veh√≠culos, electrodom√©sticos, sensores, y m√°s. 
							La idea principal es que estos dispositivos puedan comunicarse entre s√≠ y con sistemas en la nube para recopilar, analizar y utilizar datos de manera eficiente.
						</p>
						<a class="item__excerpt-link" href="#content-3"><span>Leer m&aacute;s</span></a>
					</div>
				</article>
				<article class="item">
					<div class="item__imgwrap">
					</div>
					<button class="item__enter unbutton">
						<svg class="item__enter-circle" vector-effect="non-scaling-stroke" width="800" height="800" viewbox="0 0 800 800">
							<circle vector-effect="non-scaling-stroke" cx="400" cy="400" r="150"></circle>
						</svg>
					</button>
					<h2 class="heading heading--item">
						<span data-splitting="">Cr&eacute;ditos</span>
					</h2>
					<div class="item__excerpt">
						<p>Fuentes utilizadas para la creaci√≥n de esta p√°gina.</p>
						<a class="item__excerpt-link" href="#content-4"><span>Read more</span></a>
					</div>
				</article>
				
			<!-- Aqu√≠ comienza el texto de los articulos -->
			<section class="content">
				<article class="content__article" id="content-1">
					<h2 class="heading">
						<span data-splitting="">Honey</span>
						<span data-splitting="">nets</span>
					</h2>
					<div class="content__text">
						<p>
							Una honeynet son herramientas de seguridad que simula una red completa para ser atacada por intrusos. 
							Funciona como una especie de "pecera" donde se observa al atacante en su entorno. Esta red consta de sistemas dispuestos a recibir ataques, con mecanismos para monitorear y registrar las acciones del intruso. Estudiar el comportamiento del atacante permite entender sus t√°cticas y motivaciones. 
							Las honeynets son los honeypots m√°s avanzados y esta presentaci√≥n destaca su poder, examina diferentes propuestas y resalta la importancia de su virtualizaci√≥n. 
						</p>
						<img src="/honeynetstxt1.8c728074.jpg" alt="Some image">
						<p>
							Una honeypot es una herramienta que se utiliza como se√±uelo, con el fin de ser atacada, por esto todo tr√°fico que pase por ella ser√° detectado como un ataque o intrusi√≥n. 
							Una honeypot no tendr√° comunicaci√≥n alguna con ninguna entidad y, en caso de detectar tr√°fico cuyo origen sea el honeypot, este ser√° tomado inmediatamente como una amenaza.
						</p>
						<p>
							Por lo tanto, una honeynet representa la forma m√°s sofisticada de honeypot, ofreciendo un alto nivel de interacci√≥n con los intrusos y permitiendo una recopilaci√≥n extensa de datos sobre ataques. 
							Sin ser una herramienta lista para ser instalada, es una red completa con sistemas dise√±ados para ser atacados, pudiendo simular cualquier componente de red, incluyendo routers y switches, imitando as√≠ una red real de una organizaci√≥n.
						</p>
						<p>
							El desarrollo de estas redes ha sido impulsado por el Honeynet Project, fundado en el a√±o 2000, cuyo prop√≥sito es comprender las t√©cnicas y motivaciones de los atacantes y compartir conocimientos al respecto. 
							Este proyecto re√∫ne a expertos en sistemas operativos, desarrolladores de herramientas de seguridad, psic√≥logos y otros perfiles diversos. 
						</p>
						<img src="/honeynetstxt2.1dd26eb8.png" alt="Some image">
						<p>
							Adem√°s de los sistemas destinados a recibir ataques, una honeynet incluye dispositivos adicionales para detectar, filtrar y registrar el tr√°fico entrante y saliente, as√≠ como las acciones de los intrusos una vez que comprometen un sistema simulado. 
							Todo esto se realiza de manera pasiva para no alertar al intruso sobre su monitoreo. Estos dispositivos cumplen funciones clave:
							</p><ul>
								<li>
									<strong>Control del intruso:</strong> Filtrar las conexiones nocivas del intruso y evitar que utilice sistemas comprometidos para atacar otros recursos.
								</li>
								<li>
									<strong>Captura de datos:</strong> Registrar todo el tr√°fico dentro y fuera de la honeynet, as√≠ como las acciones del intruso en sistemas comprometidos para estudiar t√°cticas y motivaciones de los atacantes.
								</li>
								<li>
									<strong>Centralizaci√≥n de informaci√≥n:</strong> Enviar de manera segura los datos capturados a un servidor centralizado para su almacenamiento y an√°lisis, permitiendo un mejor control y an√°lisis de las experiencias recopiladas y una visi√≥n m√°s clara de los diferentes tipos de ataques en la red.
								</li>
							</ul>
						<p></p>
						<p>
							La eficacia de una honeynet radica en su capacidad para recopilar datos detallados, esenciales para entender y combatir las amenazas cibern√©ticas, 
							permitiendo un an√°lisis exhaustivo de las t√°cticas utilizadas por los atacantes y facilitando estrategias de defensa m√°s robustas.
						</p>
						<p>
							Volviendo con el proyecto honeynet, muestran las herramientas usadas para la recolecci√≥n de datos en honeynet aunque solo muestran las m√°s usadas por la organizaci√≥n:
							</p><ul>
								<li><strong>Honeyned:</strong> Emula los almacena IP de varios sistemas operativos y provee de manera opcional servicio de emulaci√≥n b√°sica.</li>
								<li><strong>Nephentes:</strong> Emula vulnerabilidades comunes de MS Windows; es extremadamente bueno capturando malware como gusanos.</li>
								<li><strong>Honeytrap:</strong> Detecta intentos de conexi√≥n contra puertos TCP no conectados.</li>
								<li><strong>Kojoney:</strong> Emula los procesos de un servidor SSH y graba los nombres de usuario y contrase√±as de los atacantes.</li>
								<li><strong>Sebek:</strong> Monitorea los honepots de alta interacci√≥n, engancha llamadas de lectura o escritura para manipular el acceso de archivos o actividad de entrada y salida.</li>
								<li><strong>Hflow:</strong> Cruza datos obtenidos en Snort, pof y sebek en una estructura de datos relacionada para almacenamiento en una base de datos terminal.</li>
								<li><strong>Honeywall:</strong> Es usando para construir de forma r√°pida una honeynet de alta interacci√≥n. Permite un an√°lisis y control transparente de los datos.</li>
								<li><strong>Capture HPC:</strong> Ejecuta aplicaciones dentro de una m√°quina virtual de Windows, aunque su mayor uso ha sido encontrar posibles URL maliciosas.</li>
								<li><strong>SpamPot:</strong> Colecciona y analiza mensajes v√≠a email.</li>
							</ul>
						<p></p>
						<p>
							Sin embargo, existen algunos inconvenientes en el uso de este tipo de herramientas pues se requiere de una instalaci√≥n con total precisi√≥n y cuidado, de tal forma que la seguridad de la red no se vea comprometida en este punto, adem√°s de otros problemas legales que esto acarrear√≠a.
						</p>
						<p>
							Por lo tanto, las honeynets Son herramientas altamente especializadas dise√±adas para simular entornos de red completos y capturar informaci√≥n detallada sobre t√°cticas de ataque y comportamiento de los intrusos, esta informaci√≥n es vital para entender las amenazas y mejorar las defensas de seguridad. 
							La evoluci√≥n de las honeynets se ha producido gracias a proyectos como el Honeynet Project, que re√∫ne a expertos de diversos campos para comprender mejor las t√°cticas y motivaciones de los atacantes, mejorando as√≠ las estrategias de defensa cibern√©tica. 
							Aunque pasivamente monitorean las acciones de los intrusos para no alertarlos, activamente controlan y filtran las conexiones maliciosas para evitar da√±os mayores.
						</p>
					</div>
				</article>
				<article class="content__article content__article--invert" id="content-2">
					<h2 class="heading">
						<span data-splitting="">Tunelizaci&oacute;n</span>
						<span data-splitting="">(Tunneling)</span>
					</h2>
					<div class="content__text">
						<p>
							La encapsulaci√≥n de paquetes en la tunelizaci√≥n se logra mediante el envoltorio de un paquete de datos completo que utiliza un protocolo de comunicaciones diferente dentro del datagrama de un protocolo de tunelizaci√≥n. 
							El paquete encapsulado se transmite a trav√©s de la red y se desencapsula en el extremo receptor para recuperar el paquete original.
						</p>
						<img style="width: 60%; height: auto;
" src="/tunnelingtxt1.ff02f2f1.png" alt="some image">
						<p>
							Por ejemplo, el protocolo de enrutamiento gen√©rico (GRE) es un protocolo de tunelizaci√≥n que encapsula paquetes de datos que utilizan un protocolo de enrutamiento dentro de los paquetes de otro protocolo. GRE permite el uso de protocolos que no suelen ser compatibles con una red, porque los paquetes est√°n envueltos dentro de otros paquetes que s√≠ utilizan protocolos compatibles. 
						</p>
						<p>
							La encapsulaci√≥n es √∫til porque permite dividir un flujo de datos en unidades m√°s peque√±as para las transmisiones a trav√©s de la red, lo que aumenta la velocidad y la eficiencia de la transmisi√≥n. 
							Adem√°s, la encapsulaci√≥n ayuda a aumentar la seguridad de los datos y la privacidad del acceso no autorizado
						</p>
						<p>
							No obstante, no estamos exentos de riesgos en la red. Un t√∫nel VPN es una conexi√≥n encriptada entre tu dispositivo e internet. 
							Los hackers, snoopers, ISPs y gobiernos pueden transformar tu vida digital en un infierno. No es muy dif√≠cil que nos hackeen en internet, sufrir los efectos de la censura o encontrarnos con una barrera para acceder a ciertos servicios. 
							Un t√∫nel VPN te ayudar√° a protegerte de todos estos problemas. Un t√∫nel VPN es una conexi√≥n encriptada entre tu dispositivo e internet. 
							Al descargar una VPN para conectarte a internet, tu tr√°fico de internet pasa a trav√©s de un t√∫nel encriptado, asegura tus datos y los redirige a uno de los servidores del proveedor VPN. Puedes sentarte frente a tu equipo en el Reino Unido y pretender que est√°s en Canad√°. 
							Ni los ISPs ni los hackers podr√°n identificarte, espiar tus datos o rastrear tu ubicaci√≥n.
						</p>
						<img style="width: 60%; height: auto;
" src="/tunnelingtxt2.24455b09.png" alt="some image">
						<p>
							Tipos de protocolos:
							</p><ul>
								<li><strong>PPP (Point-to-Point Protocol): </strong>Es un protocolo del nivel de enlace de datos, utilizado para establecer una conexi√≥n directa entre dos nodos de una red. Se emplea en varios tipos de redes f√≠sicas, incluyendo: l√≠nea telef√≥nica, telefon√≠a celular y enlace de fibra √≥ptica.</li>
								<li><strong>GRE (Generic Routing Encapsulation):</strong> Es un protocolo para el establecimiento de t√∫neles a trav√©s de Internet, que soporta secuencialidad de paquetes, permite establecer pol√≠ticas de enrutamiento y seguridad, facilita encapsular una amplia variedad de tipos de paquete dentro de t√∫neles IP.</li>
								<li><strong>PPTP (Point-to-Point Tunneling Protocol):</strong> Es un protocolo de comunicaciones actualmente en desuso, que permite el intercambio seguro de datos de un cliente a un servidor formando una Red Privada Virtual (VPN).</li>
								<li><strong>PSec (Internet Protocol Security):</strong> su funci√≥n es asegurar las comunicaciones IP y a los protocolos de capas superiores, autenticando y/o cifrando cada paquete de datos que se intercambia.</li>
							</ul>
						<p></p>
						<img src="/tunnelingtxt3.99d9e19d.png" alt="some image">
						<p>
							Existen m√°s protocolos referentes a la tunelizaci√≥n, no obstante solo elegimos estos para fines pr√°cticos.
						</p>
					</div>
				</article>
				<article class="content__article" id="content-3">
					<h2 class="heading">
						<span data-splitting="">Internet</span>
						<span data-splitting="">of</span>
						<span data-splitting="">Things</span>
					</h2>
					<div class="content__text">
						<p>
							La IoT se refiere a la interconexi√≥n en red de todos los objetos cotidianos, que a menudo est√°n equipados con alg√∫n tipo de inteligencia. 
							En este contexto, Internet puede ser tambi√©n una plataforma para dispositivos que se comunican electr√≥nicamente y comparten informaci√≥n y datos espec√≠ficos con el mundo que les rodea. 
							As√≠, la IoT puede verse como una verdadera evoluci√≥n de lo que conocemos como Internet a√±adiendo una interconectividad m√°s extensa, una mejor percepci√≥n de la informaci√≥n y servicios inteligentes m√°s completos. 
							En su mayor parte, se utiliz√≥ la Internet para protocolos orientados a la conexi√≥n de aplicaciones como HTTP (Protocolo de transferencia de hipertexto) y SMTP (Simple Mail Transfer Protocol). Sin embargo, hoy en d√≠a un gran n√∫mero de dispositivos inteligentes se comunican entre ellos y con otros sistemas de control. 
							Este concepto se conoce como M2M (comunicaciones de m√°quina a m√°quina). 
						</p>
						<img src="/iottext1.e444c210.png" alt="Some image">
						<p>
							Hay tres componentes o elementos b√°sicos que interact√∫an entre s√≠:
							</p><ul>
								<li><strong>Hardware:</strong> sensores, actuadores (dispositivos que controlan los sistemas) y otros dispositivos de comunicaci√≥n alojados en los objetos;</li>
								<li><strong>Plataforma de middleware:</strong> Que es el software que permite el intercambio de informaci√≥n entre las aplicaciones, as√≠ como las herramientas computacionales que permitan el an√°lisis de datos</li>
								<li>Las herramientas que en forma f√°cil permitan la visualizaci√≥n e interpretaci√≥n de la informaci√≥n y que deben ser dise√±adas para ser accesadas por diferentes aplicaciones y dispositivos</li>
							</ul>
						<p></p>
						<p>
							Actualmente, IoT est√° compuesta por una colecci√≥n dispersa de redes diferentes y con distintos fines. Por ejemplo, los autom√≥viles actuales tienen m√∫ltiples redes para controlar el funcionamiento del motor, las medidas de seguridad, los sistemas de comunicaci√≥n y as√≠ sucesivamente. 
							De forma similar, los edificios comerciales y residenciales tienen distintos sistemas de control para la calefacci√≥n, la ventilaci√≥n y el aire acondicionado, la telefon√≠a, la seguridad y la iluminaci√≥n. A medida que IoT evoluciona, estas redes y muchas otras estar√°n conectadas con la incorporaci√≥n de capacidades de seguridad, an√°lisis y administraci√≥n.
						</p>
						<img src="/iottext2.b50d6454.png" alt="Some image">
						<p>
							A medida que sigue aumentando la poblaci√≥n del planeta, se torna cada vez m√°s importante que las personas se conviertan en guardianes de la Tierra y sus recursos. Adem√°s, las personas desean vidas saludables, plenas y confortables para s√≠ mismas, sus familias y las personas que quieren. Si se combina la capacidad de la pr√≥xima evoluci√≥n de Internet (IoT) para percibir, recolectar, transmitir, analizar y distribuir datos a escala masiva con la manera en que las personas procesan la informaci√≥n, la humanidad tendr√° el conocimiento y la sabidur√≠a necesarios no solo para sobrevivir sino para mejorar y prosperar en los pr√≥ximos meses, a√±os, d√©cadas y siglos. 
						</p>
						<p>
							El IoT tiene el potencial de mejorar la eficiencia y la comodidad en diversas √°reas, como la dom√≥tica, la salud, la agricultura, la industria y el transporte. Los dispositivos IoT pueden recopilar informaci√≥n en tiempo real, automatizar procesos y permitir a los usuarios tomar decisiones informadas basadas en datos.
						</p>
						<p>
							No obstante, son varias las barreras que podr√≠an retrasar el desarrollo de IoT. Las tres barreras de mayor magnitud son la implementaci√≥n de IPv6, la energ√≠a para alimentar los sensores y el acuerdo sobre las normas.
							</p><ul>
								<li><strong>Implementaci√≥n de IPv6:</strong> En febrero de 2010, se agotaron las direcciones IPv4 del mundo. Si bien el p√∫blico general no ha observado un impacto real, esta situaci√≥n podr√≠a lentificar el progreso de IoT, ya que los posibles miles de millones de sensores necesitar√°n direcciones IP exclusivas. Adem√°s, IPv6 facilita la administraci√≥n de las redes gracias a las capacidades de autoconfiguraci√≥n y ofrece caracter√≠sticas de seguridad mejoradas. </li>
								<li><strong>Energ√≠a para los sensores:</strong> Para que IoT alcance su m√°ximo potencial, los sensores deber√°n ser autosustentables. Imagine cambiar las bater√≠as de miles de millones de dispositivos implementados en todo el planeta e incluso en el espacio. Obviamente, no es posible. Lo que se necesita es una forma de que los sensores generen electricidad a partir de elementos medioambientales como las vibraciones, la luz y las corrientes de aire.</li>
								<li><strong>Normas:</strong> Si bien se han realizado grandes progresos en cuanto a las normas, se necesita a√∫n m√°s, especialmente en las √°reas de seguridad, privacidad, arquitectura y comunicaciones, ya que la gran cantidad de informaci√≥n generada y compartida puede ser vulnerable a amenazas cibern√©ticas. IEEE es solo una de las organizaciones que actualmente trabajan para sortear estas dificultades, con la tarea de garantizar que los paquetes de IPv6 se puedan direccionar a trav√©s de tipos de red diferentes.</li>
							</ul>
						<p></p>
					</div>
				</article>
				<article class="content__article" id="content-4">
					<h2 class="heading">
						<span data-splitting="">Creditos</span>
					</h2>
					<div class="content__text">
						<p>
							</p><ul>
								<li>Gallego, E., L√≥pez, J. (s.f.). <em>Honeynets: Aprendiendo del Atacante.</em> Departamento de Ingenier√≠a de Sistemas Telem√°ticos, Universidad Polit√©cnica de Madrid E.T.S.I. de Telecomunicaci√≥n, Av. Complutense, s/n, 28040 Madrid, Espa√±a.</li>
								<li>Gaona, P., Montenegro, C., Bar√≥n, J. (2016). <em>Modelo ontol√≥gico para la predicci√≥n de ataques inform√°ticos a partir de Honeynets virtualizadas.</em></li>
								<li>BTOBAdmin. (2022, 1 septiembre). ¬øQU√â SIGNIFICA HACER T√öNEL? (TUNNELING PROTOCOL) | BTOB Consultores. BTOB Consultores. https://btob.com.mx/ciberseguridad/que-significa-hacer-tunel/</li>
								<li>¬øQu√© es un protocolo de tunelizaci√≥n? (2023, 19 abril). latam.kaspersky.com. https://latam.kaspersky.com/resource-center/definitions/tunneling-protocol </li>
								<li>Salazar J., Silvestre S., (2020) Internet de las cosas. Tech pedia, recuperado de https://upcommons.upc.edu/bitstream/handle/2117/100921/LM08_R_ES.pdf</li>
								<li>Evans D., (2011). Internet de las cosas C√≥mo la pr√≥xima evoluci√≥n de Internet lo cambia todo. Cisco, recuperado de  https://www.cisco.com/c/dam/global/es_mx/solutions/executive/assets/pdf/ <br> internet-of-things-iot-ibsg.pdf</li>
								<li>Bonilla-Fabela, I., Tavizon-Salazar, A., et. al. (2016) IoT, el internet de las cosas y la innovaci√≥n de sus aplicaciones. ISSN: 2448-5101 A√±o 2 N√∫mero 1, recuperado de http://www.web.facpya.uanl.mx/Vinculategica/Revistas/R2/2313-2340%20-%20Iot,%20El%20Internet%20De%20Las%20Cosas%20Y%20La%20Innovacion <br> %20De%20Sus%20Aplicaciones.pdf</li>
							</ul>
						<p></p>
					</div>
				</article>
				<button class="content__back unbutton">
					<svg width="108" height="23" viewbox="0 0 108 23">
						<path stroke="#000" fill="none" d="M107.5 11.5H1.5M1.5 11.5c8.975-.536 15.087-1.364 18.336-2.484C23.086 7.896 26.64 5.39 30.5 1.5M1.5 11.5c8.975.536 15.087 1.364 18.336 2.484 3.25 1.12 6.804 3.626 10.664 7.516"></path>
					</svg>
				</button>
			</section>
		</section></main>
		<footer class="frame__links frame frame--footer footerlink">
			<a target="_blank">&copy;</a>
			<a target="_blank">Luis Juarez</a>
			<a target="_blank">Iv&aacute;n Cetina</a>
			<a target="_blank">Carlos Greene</a>
			<a target="_blank">Irving Poot</a>
		</footer>
		<script src="/index.2142d36c.js"></script>
	</body>
</html>